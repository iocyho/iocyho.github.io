---
title: 《程序是怎样跑起来的》读书笔记
---

### 对程序员而言，CPU是什么？
* CPU内部由寄存器、控制器、运算器、时钟四个主要部分组成
	* **寄存器**用来暂存指令、数据等处理对象，**可以看作是<font color=red>一种特殊的内存</font>**
	* **控制器**控制器负责把内存上的指令、数据等读入寄存器，并根据指令执行结果控制计算机
	* **运算器**负责运算从内存读入寄存器的数据
	* **时钟**负责发出CPU开始计时的信号
* CPU可以执行的指令种类
	* <font size=3>**程序可以写得非常复杂，但是CPU本身能做的事情非常简单**</font>
	1. 数据送达指令
		* 寄存器与内存、内存与内存、寄存器与与外围设备间的数据读写操作
	2. 运算指令
		* 累加寄存器执行算术运算、逻辑运算、比较运算与位移运算
	3. 跳转指令
		* 实现条件分支、循环、强制跳转等
	4. call/return指令
		* 函数调用/返回调用前的地址
* CPU是寄存器的集合体
	* 程序是指令和数据的集合
	* 程序启动后，操作系统将程序从磁盘复制到主内存
	* 时钟信号发生器发出时钟信号
	* 根据时钟信号，控制器从主内存中读取指令和数据，加载进寄存器
	* 运算器对寄存器中的指令进行解释和运行，对数据进行运算
	* 控制器根据运算结果控制计算机
	* 使用高级语言编写的程序，最后都会编译转化为机器语言，通过CPU内部的寄存器来处理。
	* 对程序员而言，**<font size=4>CPU是寄存器的集合体</font>**

* 寄存器分类
	* 累加寄存器(accumulator register)
		* 存储执运算时的数据和运算后的数据
	* 标志寄存器(flag register)
		* 存储运算处理后的CPU状态(运算结果)
		* 跳转指令可以向程序计数器指定地址
		* 是否执行跳转则需要根据标志寄存器中的值来判断
		* 标志寄存器有3位分别存储运算结果是否为正、是否为0、是否为负
	* 程序计数器(program counter)
		* 存储下一条指令所在的内存地址，* **<font size=3>决定程序的执行流程</font>**
		* 程序运行过程中，这里存储的地址值自增，就是程序的顺序执行
		* 程序运行过程中，向这里指定存储的地址值，就实现了**跳转**。
		* 分支是根据条件执行指定地址中存储的指令
		* 循环是重复执行同一地址中存储的指令
	* 基址寄存器(base register)
		* 存储数据内存的起始地址
		* 与变址寄存器一起，可以在物理上实现数组
	* 变址寄存器(index register)
		* 存储基址寄存器的想的相对地址
		* 就是数组索引的物理实现
		* 与基址寄存器一起，可以在物理上实现数组
	* 通用寄存器(general purpose register)
		* 存储任意数据
	* 指令寄存器(instruction register)
		* 存储指令。CPU内部使用，程序员无法通过程序对该寄存器进行操作。
	* 栈寄存器(stack register)
		* 存储栈区域的起始地址。实现函数(方法)的基础。
* 比较的实现机制
	* 程序中对a和b进行大小比较，本质上就是CPU内部在做a-b的减法运算
	* 无论运算结果为正、为0、为负，都会存储在标志寄存器中
	* 结果为正，说明a比b大；结果为0,说明两者相等；结果为负，说明a比b小
* 函数调用的实现机制
	* 函数调用也是通过把程序即使器中的值设置为存储函数的地址来实现的
	* 与分支、循环不同之处在于，函数的调用需要在完成函数内部的处理后，处理流程再返回函数的调用点。因此仅仅通过跳转指令无法实现函数调用。(因为函数中的各条指令再内存中是分散存储的，无法判断什么时候该跳转回来)
	* 高级编程语言进行编译后，函数调用处理会转换为call指令，函数结束处理会转换成return指
	* 使用**call指令**实现函数调用，将函数入口地址设置到程序计数器之前，call指令会将函数被调用后要执行的指令统一存储(原本是在内存中分散存储的)到名为"栈"的主内存中(方法入栈)
	* 函数处理完毕后，再通过函数的出口来执行**return指令**，将保存在栈中的地址(函数调用点的下一条指令的地址)设置到程序计数器中令
* 数组和索引的实现机制
	* 数组本质上就是在内存中划分出的一段连续的存储区域
	* 这段连续区域的划分，通过**基址寄存器**+**变址寄存器**来实现
	* 基址寄存器存储数组的起始内存地址
	* 变址寄存器存储数组地址相对起始地址的变化范围。变址内存器中存储的值就相当于高级编程语言中数组的索引。
	* 如查询10000地址~10FFF时，可以将10000存入基址寄存器，使变址寄存器的值在0000~0FFF的范围内变化即可。