---
title: 设计模式
---

### 1.创建型模式
* 核心作用：创建对象

#### 1.1单例模式
* 构造器器私有
* 提供静态私有属性（创建出来的对象长期驻留内存）
* 饿汉式
	* 类加载时立即初始化属性
	* 直观的(没有线程安全问题，调用效率高，但是暂用资源)
	* 枚举(枚举元素天然单例，避免反射和反序列化的漏洞，调用效率高，但是不支持延时加载) 不需要延时加载时优先选择
* 懒汉式
	* 类加载时不会立即初始化属性，到调用时再加载
	* 直观的(延时加载，资源占用少，但是需要解决线程安全问题，调用效率低)
	* 静态内部类(兼具延时加载、线程安全和调用效率高的有点) 需要延时加载时优先选择
* 反射破解单例模式(不包括枚举实现的)
	* 通过反射获取的对象是新的对象(不再单例)
	* 解决方法：再构造函数中加判断条件，当instance不为空时直接抛异常
* 反序列化破解单例模式
	* 序列化再反序列化获取的对象是新对象(不在单例)
	* 解决方法：类中定义readResolve()方法，反序列化时直接调用，将现有的instance返回
* 多线程测试单例模式
	* CountDownLatch：同步辅助类，完成一组正在其他线程中的操作之前，允许其他线程一直等待
		* countDown() 当前线程调用此方法，则计数减1(建议在finally中执行)
		* await() 调用此方法会一直阻塞当前线程，直到计数为0

#### 1.2工厂模式
* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式

#### 1.3建造者模式
* 分离了对象子组件的单独单独构造(Builder负责)和装配(Director负责),从而可以构造复杂对象
* 实现了构造与装配的解耦，不同的构造Builder和Director组合可以创建出不同的对象

#### 1.4原型模式
* 以某个对象为原型，复制出与原型属性值完全相同的新的对象。修改克隆出的新对象不会影响原有对象的属性值。
* 省略了new对象是的一系列繁琐步骤
* 适用于需要大量创建复杂对象的场景
* 实现
	* 使用原型模式需要完成内存的复制操作
	* 实现cloneable接口
	* 重写Object类的clone()方法
* 深克隆与浅克隆
	* 浅克隆
		* 原型对象的属性是对象时，克隆出的新对象复制的成员变量的地址值
		* 原型对象与克隆对象的属性指向同一个对象，在任何一方修改都会影响其他对象
	* 深克隆
		* 原型对象的成员变量是对象时，克隆出的新对象把成员变量也创建了一个新对象
		* 原型对象与克隆对象的属性指向不同对象
		* 实现
			* 重写clone()方法的时候硬编码实现
			* 通过序列化和反序列化实现
* 使用场景
	* 需要短时间内创建大量对象，且new的过程比较耗时，就可以采用原型模式


### 2.结构型模式
* 核心作用：从程序结构上实现解耦，扩大整体类结构，解决更大的问题

#### 2.1适配器模式
* 将一个类的接口转换成客户端希望的另一个接口。可以使原本不兼容的不能一起工作的类可以一起工作。
* 模式中的角色
	* 目标接口(Target)：客户端期待的接口，可以时具体或抽象类，也可以是接口
	* 需要适配的类(Adaptee)：需要适配的类或适配者类
	* 适配器(Adapter)：通过包装一个需要适配的对象，把原接口转换成目标接口
* 使用场景
	* 对旧系统的改造和升级
	* eg: 字节流转换为字符流
		* java.io.InputStreamReader(InputStream)
		* java.io.OutputStreamWriter(OutputStream)
* 实现方式
	* 类适配器
		* 适配器(Adapter)实现目标接口，同时继承需要适配的类(Adaptee)，通过调用父类方法的方式实现转接
			````
			public Adapter extends Adaptee implements Target{
				public void request(){
					super.specificRequest();
				}
			}
			````
		* 适配器(Adapter)实现目标接口，把需要适配的类(Adaptee)作为成员变量，通过调用成员变量的方法实现转接
			```
			public class Adapter implements Target{
				private Adaptee adaptee;
				
				public Adapter(Adaptee adaptee){
					this.adaptee = adaptee;
				}
				
				public void request(){
					this.adaptee.specificRequest();
				}
			}
			```

#### 2.2代理模式
* 实现类与代理类实现共同的抽象接口
* 核心作用：通过代理,控制对对象的访问(在不改变类(对象)本身的情况下对方法进行增强)
* 核心角色：
	* 抽象角色
		* 抽象接口
	* 真实角色
		* 实现接口，提供实际服务
	* 代理角色
		* 服务调用方的代理实现类，实现抽象接口，但是通过真实角色来完成核心业务，并且可以附加自己的操作
* 应用场景
	* 安全代理 屏蔽对真实角色的直接访问
	* 远程代理 通过代理类进行远程方法调用 RMI/RPC
	* 延迟加载 先加载轻量级的代理对象，再加载重量级的实际对象
* 静态代理：静态定义代理类
* 动态代理：动态生成代理类
	* 实现方法
		* JDK自带的动态代理
			* java.lang.reflect.Proxy
				* 动态生成代理类和对象
			* java.lang.reflect.InvocationHandler(处理器接口)
				* 可以通过invoke方法实现对真实角色的代理访问
				* 每次通过Proxy生成代理类对象时都要指定对应的处理器对象 
		* javaassist字节码操作实现
		* CGLIB
		* ASM(底层指令，不易维护)
	* 优点：抽象接口中声明的所有方法都被转移到调用处理器的一个集中方法处理，可以更加灵活统一地处理众多方法

#### 2.3桥接模式


#### 2.4装饰模式


#### 2.5组合模式


#### 2.6外观模式


#### 2.7享元模式



### 3.行为型模式


#### 3.1责任链模式


#### 3.2迭代器模式


#### 3.3中介者模式


#### 3.4命令模式


#### 3.5解释器模式




### *施工中...*