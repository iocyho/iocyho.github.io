---
title: 设计模式
---

### 1.创建型模式
* 核心作用：创建对象

#### 1.1单例模式
* 构造器器私有
* 提供静态私有属性（创建出来的对象长期驻留内存）
* 饿汉式
	* 类加载时立即初始化属性
	* 直观的(没有线程安全问题，调用效率高，但是暂用资源)
	* 枚举(枚举元素天然单例，避免反射和反序列化的漏洞，调用效率高，但是不支持延时加载) 不需要延时加载时优先选择
* 懒汉式
	* 类加载时不会立即初始化属性，到调用时再加载
	* 直观的(延时加载，资源占用少，但是需要解决线程安全问题，调用效率低)
	* 静态内部类(兼具延时加载、线程安全和调用效率高的有点) 需要延时加载时优先选择
* 反射破解单例模式(不包括枚举实现的)
	* 通过反射获取的对象是新的对象(不再单例)
	* 解决方法：再构造函数中加判断条件，当instance不为空时直接抛异常
* 反序列化破解单例模式
	* 序列化再反序列化获取的对象是新对象(不在单例)
	* 解决方法：类中定义readResolve()方法，反序列化时直接调用，将现有的instance返回
* 多线程测试单例模式
	* CountDownLatch：同步辅助类，完成一组正在其他线程中的操作之前，允许其他线程一直等待
		* countDown() 当前线程调用此方法，则计数减1(建议在finally中执行)
		* await() 调用此方法会一直阻塞当前线程，直到计数为0

#### 1.2工厂模式
* 简单工厂模式
* 工厂方法模式
* 抽象工厂模式

#### 1.3建造者模式
* 分离了对象子组件的单独单独构造(Builder负责)和装配(Director负责),从而可以构造复杂对象
* 实现了构造与装配的解耦，不同的构造Builder和Director组合可以创建出不同的对象

#### 1.4原型模式
* 以某个对象为原型，复制出与原型属性值完全相同的新的对象。修改克隆出的新对象不会影响原有对象的属性值。
* 省略了new对象是的一系列繁琐步骤
* 适用于需要大量创建复杂对象的场景
* 实现
	* 使用原型模式需要完成内存的复制操作
	* 实现cloneable接口
	* 重写Object类的clone()方法
* 深克隆与浅克隆
	* 浅克隆
		* 原型对象的属性是对象时，克隆出的新对象复制的成员变量的地址值
		* 原型对象与克隆对象的属性指向同一个对象，在任何一方修改都会影响其他对象
	* 深克隆
		* 原型对象的成员变量是对象时，克隆出的新对象把成员变量也创建了一个新对象
		* 原型对象与克隆对象的属性指向不同对象
		* 实现
			* 重写clone()方法的时候硬编码实现
			* 通过序列化和反序列化实现
* 使用场景
	* 需要短时间内创建大量对象，且new的过程比较耗时，就可以采用原型模式


### 2.结构型模式
* 核心作用：从程序结构上实现解耦，扩大整体类结构，解决更大的问题

#### 2.1适配器模式
* 将一个类的接口转换成客户端希望的另一个接口。可以使原本不兼容的不能一起工作的类可以一起工作。
* 模式中的角色
	* 目标接口(Target)：客户端期待的接口，可以时具体或抽象类，也可以是接口
	* 需要适配的类(Adaptee)：需要适配的类或适配者类
	* 适配器(Adapter)：通过包装一个需要适配的对象，把原接口转换成目标接口
* 使用场景
	* 对旧系统的改造和升级
	* eg: 字节流转换为字符流
		* java.io.InputStreamReader(InputStream)
		* java.io.OutputStreamWriter(OutputStream)
* 实现方式
	* 类适配器
		* 适配器(Adapter)实现目标接口，同时继承需要适配的类(Adaptee)，通过调用父类方法的方式实现转接
			````
			public Adapter extends Adaptee implements Target{
				public void request(){
					super.specificRequest();
				}
			}
			````
		* 适配器(Adapter)实现目标接口，把需要适配的类(Adaptee)作为成员变量，通过调用成员变量的方法实现转接
			```
			public class Adapter implements Target{
				private Adaptee adaptee;
				
				public Adapter(Adaptee adaptee){
					this.adaptee = adaptee;
				}
				
				public void request(){
					this.adaptee.specificRequest();
				}
			}
			```

#### 2.2代理模式
* 实现类与代理类实现共同的抽象接口
* 核心作用：通过代理,控制对对象的访问(在不改变类(对象)本身的情况下对方法进行增强)
* 核心角色：
	* 抽象角色
		* 抽象接口
	* 真实角色
		* 实现接口，提供实际服务
	* 代理角色
		* 服务调用方的代理实现类，实现抽象接口，但是通过真实角色来完成核心业务，并且可以附加自己的操作
* 应用场景
	* 安全代理 屏蔽对真实角色的直接访问
	* 远程代理 通过代理类进行远程方法调用 RMI/RPC
	* 延迟加载 先加载轻量级的代理对象，再加载重量级的实际对象
* 静态代理：静态定义代理类
* 动态代理：动态生成代理类
	* 实现方法
		* JDK自带的动态代理
			* java.lang.reflect.Proxy
				* 动态生成代理类和对象
			* java.lang.reflect.InvocationHandler(处理器接口)
				* 可以通过invoke方法实现对真实角色的代理访问
				* 每次通过Proxy生成代理类对象时都要指定对应的处理器对象 
		* javaassist字节码操作实现
		* CGLIB
		* ASM(底层指令，不易维护)
	* 优点：抽象接口中声明的所有方法都被转移到调用处理器的一个集中方法处理，可以更加灵活统一地处理众多方法

#### 2.3桥接模式
* 核心：处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使得各个维度可以独立地扩展在抽象层建立关联
* 作用：
	* 取代多层继承的方案
	* 提高系统可扩展性
* 使用场景：
	* JDBC驱动程序
	* 银行日志管理
		* 格式分类：操作日志、交易日志、异常日志
		* 距离分类：本地记录日志、异地记录日志
	* 人力资源系统中的奖金计算模块
		* 奖金分类：个人奖金、团体奖金、激励奖金
		* 部门分类：人事部门、销售部门、研发部门
	* OA系统中的消息处理
		* 业务类型：普通消息、加急消息、特急消息
		* 发送消息方式：系统内消息、手机短信、邮件

#### 2.4装饰模式
* 作用
	* 动态地增加或删除对象的功能，使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新的具体构建类和具体装饰类
	* 一种用于替代继承的技术，<font face="黑体" color="red" size="4">无需通过继承增加子类就能扩展对象的新功能</font>。使用对象的关联关系替代继承关系，更加灵活，也<font color = "red" size="4">避免类型体系的快速膨胀</font>。
* 优点
	* 扩展对象功能比继承灵活，不会导致类的个数急剧增加
	* 可以对一个对象进行多次装饰，创造不同的行为组合，得到功能更强大的对象
	* 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类
* 核心角色：
	* Component抽象构件
		* 真实对象和装饰对象具有相同的接口。客户端对象能够以与真实对象相同的方式与装饰对象交互
	* ConcreteComponent具体构件(真实对象)
		* 比如io流中的FileInputStream、FileOutputStream
	* Decorator装饰
		* 持有一个抽象对象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象，从而实现在真实对象前后增加新的功能
	* ConcreteDecorator具体装饰
		* 负责给构件对象增加新的责任
* 桥接模式与装饰模式
	* 相同点：都是为了解决过多子类对象的问题
	* 不同点：诱因不同
		* 桥接模式是为了解决现象自身现有机制沿着多个维度变化导致的多重继承问题
		* 装饰模式是为了增加新的功能

#### 2.5组合模式
* 使用场景：
	* 把部分和整体的关系用树形结构表示，从而使客户端可以使用统一的方式处理部分对象和整体对象
* 核心角色：
	* 抽象构件(Component):定义叶子和容器构件的共同点
	* 叶子(Leaf)构件:无子节点
	* 容器(Composite)构件:有容器特征，可以包含子节点
* 工作流分析
	* 为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性地对待容器和叶子
	* 当容器对象的指定方法被调用时，将遍整个树形结构，寻找也包含这个方法的成员，并调用执行。其中使用了递归机制对整个结构进行处理。
* 应用场景
	* 操作系统资源管理器
	* GUI的容器层次图
	* XML文件解析
	* OA系统中，组织结构的处理
	* Junit单元测试框架
		* TestCase(叶子)、TestUnite(容器)、Test接口(抽象)

#### 2.6外观模式


#### 2.7享元模式
 


### 3.行为型模式


#### 3.1责任链模式


#### 3.2迭代器模式


#### 3.3中介者模式


#### 3.4命令模式


#### 3.5解释器模式




### *施工中...*