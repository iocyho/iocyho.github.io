---
title: 设计模式
---

### 单例模式
* 构造器器私有
* 提供静态私有属性（创建出来的对象长期驻留内存）
* 饿汉式
	* 类加载时立即初始化属性
	* 直观的(没有线程安全问题，调用效率高，但是暂用资源)
	* 枚举(枚举元素天然单例，避免反射和反序列化的漏洞，调用效率高，但是不支持延时加载) 不需要延时加载时优先选择
* 懒汉式
	* 类加载时不会立即初始化属性，到调用时再加载
	* 直观的(延时加载，资源占用少，但是需要解决线程安全问题，调用效率低)
	* 静态内部类(兼具延时加载、线程安全和调用效率高的有点) 需要延时加载时优先选择
* 反射破解单例模式(不包括枚举实现的)
	* 通过反射获取的对象是新的对象(不再单例)
	* 解决方法：再构造函数中加判断条件，当instance不为空时直接抛异常
* 反序列化破解单例模式
	* 序列化再反序列化获取的对象是新对象(不在单例)
	* 解决方法：类中定义readResolve()方法，反序列化时直接调用，将现有的instance返回
* 多线程测试单例模式
	* CountDownLatch：同步辅助类，完成一组正在其他线程中的操作之前，允许其他线程一直等待
		* countDown() 当前线程调用此方法，则计数减1(建议在finally中执行)
		* await() 调用此方法会一直阻塞当前线程，直到计数为0


### 代理模式
* 实现类与代理类实现共同的抽象接口
* 核心作用：通过代理,控制对对象的访问(在不改变类(对象)本身的情况下对方法进行增强)
* 核心角色：
	* 抽象角色
		* 抽象接口
	* 真实角色
		* 实现接口，提供实际服务
	* 代理角色
		* 服务调用方的代理实现类，实现抽象接口，但是通过真实角色来完成核心业务，并且可以附加自己的操作
* 应用场景
	* 安全代理 屏蔽对真实角色的直接访问
	* 远程代理 通过代理类进行远程方法调用 RMI/RPC
	* 延迟加载 先加载轻量级的代理对象，再加载重量级的实际对象
* 静态代理：静态定义代理类
* 动态代理：动态生成代理类
	* 实现方法
		* JDK自带的动态代理
			* java.lang.reflect.Proxy
				* 动态生成代理类和对象
			* java.lang.reflect.InvocationHandler(处理器接口)
				* 可以通过invoke方法实现对真实角色的代理访问
				* 每次通过Proxy生成代理类对象时都要指定对应的处理器对象 
		* javaassist字节码操作实现
		* CGLIB
		* ASM(底层指令，不易维护)
	* 优点：抽象接口中声明的所有方法都被转移到调用处理器的一个集中方法处理，可以更加灵活统一地处理众多方法


### *施工中...*