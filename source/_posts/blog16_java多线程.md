---
title: Java多线程
---

#### 多线程原理
* 在windows系统中，每个独立执行的程序都被称为进程。每个进程可以包含多个线程。多线程就是在一个时间段内，CPU同时执行多个任务。系统给CPU的时间分片，每个线程会得到一小段程序执行时间，CPU一会执行这个线程的任务，一会执行那个线程的任务。由于间隔时间极短，看起来就像在同步执行。

#### 多线程实现
1. 继承Thread类，重写run方法
	* 创建一个类继承Thread类，重写run方法，将需要多线程执行的代码放入run方法中，调用Thread类的start方法。
	* 由于Java是单继承的，一个类如果继承了Thread类，就无法再继承其他类，一般不推荐使用这种方法，因为很可能还需要继承其他类(非Thread类)
2. 实现Runable接口
	* 创建一个类实现Runnable接口，实例化这个类的对象，建立Runnable对象。使用构造方法创建Thread实例，通过Thread对象调用start()方法开启新线程。

#### 多线程启动
* Thread thread = new Thread(继承了Thread的类/实现了Runnable的对象)
* thread.start()
* 开启线程用到是statr方法，而启动之后执行的是run方法

#### 线程区分
* 创建线程后，通过 thread.setName() 方法给线程设置名称就好区分了。这是一种编程规范，再创建完线程后都需要设置名称。

#### 线程并发库
* jdk1.5以后添加的DougLea并发库，引入了java.util.current包，提供了对线程优化、管理的各项操作（线程运行、线程池创建、线程生命周期管理）

#### 线程池
* 线程池的作用
	1. 限定线程的数量，避免因为线程过多导致系统运行缓慢或崩溃
	2. 使用线程池时不需要每次都创建或销毁线程，节约资源，响应更快
* 线程池使用
	* ava通过Executorst提供了4个静态方法创建线程池
		1. newCacheThreadPool 创建一个可缓存的线程池，如果线程池长度超过需要，可灵活回收空闲线程，若无可收回，则创建新线程
		2. newFixedThreadPool创建一个定长的线程池，可控制最大并发数，超过的线程会在队列中等待
		3. newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行
		4. newSingleThreadExecutor，创建一个单线程化的线程池，只会用唯一的工作线程执行任务，保证所有任务按指定顺序（优先级）进行。

#### 线程生命周期
* 创建，线程刚被创建，Thread实例创建出来，调用start()方法前
* 就绪，线程进入可执行状态，存在时间很短，会立刻切换到其他状态
* 执行，线程执行任务的过程中
* <font color=red>休眠</font>，运行中的Tread类调用sleep()方法
* <font color=red>等待</font>，运行中的Tread类调用wait()方法,必须用notify()方法才能唤醒
* <font color=red>阻塞</font>，等待其他线程执行完毕
* 死亡，任务执行完毕，线程被销毁

#### sleep()与wait()
* sleep()是Thread类的方法，wait()是object类的方法
* 调用sleep()方法，线程暂停执行，可以指定暂停时间，暂停过程中线程不会让出锁
* 抵用wait()方法，线程会让出锁，进入一个和该对象相关的等待池，直到被notifyI()或notifyAll()方法唤醒
* sleep()可以在任意地方被调用，wait、notify()、notifyAll()只能在同步代码块中调用

#### 线程安全
##### 什么是线程安全问题
* 由来
	* 来源于多个线程对单一对象数据的同时存取，比如火车站卖票问题
	* 多个线程对同一个资源同时进行写操作就会造成数据混乱
* 解决
	* 采用线程同步机制，给共享资源加锁，规定一段时间内只允许一个线程访问共享资源。就像用厕所，里面的人出来了外面的人才能进去
* 同步与异步
	* 同步就是a在执行的时候b必须等着，等a执行完之后释放锁，b再获得锁去执行。
	* 异步就是在a执行的时候，b可以去执行其他操作，待a执行完之后，b再回过头来继续执行

##### synchronized
* 作用范围
	* 修饰代码块 synchronized(Object){}
	* 修饰方法 public synchronized void method(){}
* 使用场景
	* 需要采用多线程操作共享资源的代码

##### 锁Lock
* 锁的作用
	* 效果和Sychronized类似，lock()方法加锁，unlock()方法释放锁
	* 通过Condition对象来指定线程的休眠和唤醒，await()方法让线程停止(等同于Object的wait)，signal()和signalAll()方法唤醒线程（等同于notify和notifyAll）。Condition只能唤醒由自己await的线程。
* 锁分类
	* 可重入锁 Reentrantlock
		* 可重入指可以对同一个ReentrantLock对象多次执行lock()和unlock()方法，就是可以对一个锁加多次。线程获取锁后，可以直接进入已拥有锁的同步代码块。
		* 不可重入指一个线程获取锁后，再再次进入一个新的被加锁的同步代码块时，尝试获取锁就会获取不到，被阻塞
	* 读写锁 ReentrantReadWriteLock
		* 解决锁互斥导致的效率不高问题
			* 对数据进行修改操作的时候加写锁，其他线程既不能写也不能读
			* 对数据进行读取操作的时候加读锁，其他线程可以读但是不能写
			* 在读操作远远多写操作的情况下使用读写锁区分读写操作就比直接序列化更高效。
		* 读锁  多个线程可以同时获取读锁  读读共享
			* lock.readLock().lock(),加锁
			* 加锁lock.readLock().unlock(),释放锁
		* 写锁 一次只有一个线程可以获取锁 写写互斥
			* lock.writeLock().lock() 加锁
			* lock.writeLock.unlock() 释放锁
	* 公平锁与非公平锁
		* Lock lock = new Reentranlok(false);非公平锁，抢锁机制
			* 一个线程在AQS的等待队列中被唤醒，还没来得及加锁，突然被另一个冒出来的线程抢先加锁，只能重回等待队列
			* 通过ReentrantLock的默认构造函数来创建锁，默认使用非公平机制
			* java并发包（java.util.concurrent）中的很多锁都是默认非公平的
		* Lock lock = new Reentranlock(true);公平锁，线程获取锁按依据请求加锁的先后顺序来
			* 线程在AQS的等待队列中的顺序，新冒出来的线程会先判断等待队列中是否有其他线程在等待，如果队列中存在其他线程，新线程自动加入队列
	* 悲观锁与乐观锁
		* 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度，是一种思想。
		* 悲观锁认为多个线程对同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。如synchronized
		* 乐观锁认为多个线程对同一个数据的并发操作，是不会发生修改的。如 CAS
		* 因此悲观锁适合写操作多的场景，乐观锁适合读操作多的场景。乐观锁读不处理，数据提交更新的时候，才会对数据是否产生并发冲突进行检测，如果发现冲突，则返回错误信息，让用户决定如何去做。
		
##### volatile
* 作用
	* 一个修饰符，修饰变量，解决多线程同时操作数据时，保证数据在各线程间的可见性及有序性。
* 原理
	* 多个线程操作数据时，会各自从主内存区中将数据复制一份到自己的工作内存中（相当于一个本地的高速缓存，提高效率）。
	* volatile就是保证其中一个线程对自己工作内存中的数据进行修改后，其他线程的数据也进行更改。
	* 具体就是当一个线程修改了自己工作内存中的数据后，会把修改后的数据刷新回主内存，并且其他线程工作内存中的数据会强制失效。
* 局限
	* 每次操作不是原子的，有可能被其他线程打断，多线程同时修改数据可能造成的混乱问题解决不了。

##### CAS
* CAS是什么
	* compare and set 无锁化的比较与设置，通过原子操作来避免多线程修改数据时造成的混乱，比Sychronized更轻量级，效率更高(因为不需要排队)。
	* 一个线程在对数据进行操作的时候不会被其他线程打断，同样它也不能打断其他线程的操作。
	* 先获取到数据，对数据进行修改前再获取一次，两次进行比较。一致就进行修改操作。不一致就取消操作。
	* ![CAS](https://s2.ax1x.com/2019/06/16/V7nojS.png)
* 使用CAS
	* 使用Atomic原子类即可，比如AtomicInteger，原子类的底层就是无锁化的CAS
* JDK8对CAS的优化
	* 当大量线程同时修改一个Atomic原子类的时候，很多线程可能就会不停地自旋(每次要修改都发现值变了，又要重新获取，陷入循环)，造成资源浪费。
	* JDK8通过新加入的LogAdder类，通过分段CAS以及自动分段迁移的方式来提升多线程高并发执行CAS操作的性能
		* 初始情况下有一个base值，在线程数量较少并发量较低的情况下，跟Atomic类一样，直接对base进行CAS操作。
		* 当线程较多的情况下就会执行分段，会添加cell数组，每一个数组都是数值分段，将多个线程进行分摊，对cell进行CAS操作，将计算压力分摊到多个cell。
		* 如果某个线程对一个cell执行CAS操作失败，就会自动去找其他cell，避免在一个地方线程空转，自旋等待。
		* 当需要获取LogAdder的值时，就会将base以及所有cell的值加起来返回。
		* ![JDK8优化后的CAS](https://s2.ax1x.com/2019/06/16/V7uD5n.png)

##### AQS
* AQS是什么
	* AbstractQueuedSynchronizer 抽象队列同步器，java并发包的基础类，很多API都需要基于它来实现加锁和释放锁的功能，比如ReentrantLock，ReentranReadWriteLock等。
* AQS原理
	* ![AQS原理](https://s2.ax1x.com/2019/06/16/V7uvad.png)
	* ReentrantLock包含了一个AQS对象，加锁和释放锁都需要基于AQS实现，ReentrantLock的可重入也是基于AQS实现
		* AQS中有一个核心变量state,这是一个int类型的变量，用于记录加锁状态，初始值是0。
		* AQS还有一个关键类型的变量用于记录当前的加锁线程(ExclusiveOwnerThread)，初始值为null。
		* AQS还有一个等待队列，用于存放获取锁失败，需要等待的线程。
		* 当有一个线程加锁成功后，先把state的值加1，再将exclusiveOwnerThread的值设为当前线程(final Thread current = Thread.currentThread())。
		* 如果这个线程又尝试加锁，首先判断state是否为0，不为0加锁失败。失败后再判断exclusiveOwnerThread是否为自己，是的话state属性值再加1
		* 线程1加锁成功后，如果有另外一个线程尝试加锁，发现state不为0且exclusiveOwnerThread也不是它自己，加锁失败，就会进入等待队列。
		* 释放锁就是将state的值递减。当state变为0时，彻底释放锁，把clusiveOwnerThread也修改为null。同时唤醒等待队列头部的线程，让其尝试加锁。
		* ![AQS执行流程](https://s2.ax1x.com/2019/06/16/V7uLrD.png)


##### 参考
* 微信公众号：石杉的架构笔记



